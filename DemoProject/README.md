# Console Blackjack

[Глянуть документацию](https://rawgit.com/ar1st0crat/CppCourse/master/DemoProject/doc/html/index.html)


## Ну нормально же общались...

Итак, у нас есть готовая версия игры, и она работает (*частенько такой аргументный аргумент можно слышать не только от начинающих, а даже от преисполненных понтами "бывалых"*). Зачем что-то менять? Прост )). Наша предыдущая версия плохо расширяема и практически не тестируема.

Одним из самых распространенных и заметных code smells является большое количество if-ов в коде. В самих по себе ветвлениях плохого ничего нет (да, они увеличивают цикломатическую сложность, но и ведь надо же как-то реализовать путанную и изначально ветвистую бизнес-логику). Плохо становится тогда, когда они нагромождаются друг на друга и образуют спагетти-код, который невозможно тестить. Кроме того, эти if-ы часто относятся к разным по смыслу вещам: например, в условии внешней ветки проверяется, что дилер не набрал еще 17 очков, а во внутренней - что игроку нужно начислить бонусы. 

Таким образом, если правила игры поменяются или надо будет взять имеющуюся архитектуру для написания новой игры, в коде придется повозиться немало. А хорошо сопровождаемым можно считать только тот проект, в котором для любого изменения и расширения функционала существует четко определенный: а) технический и б) концептуальный механизм. Например, если возникнет необходимость добавить новые модели поведения в приложении, любой разработчик будет знать, что конкретно и какими средствами нужно реализовать: реализовать такой-то интерфейс (введенный ранее им же или другими членами команды для применения именно в этом случае, в котором сейчас он оказался), агрегировать такой-то класс и т.д., и после этого его детище спокойно уложится в канву проекта. Интерфейсы и паттерны в таком проекте играют роль не только программистского ООП-инструментария, а еще средством выражения идей, намерений команды разработчиков и даже самодокументирования кода.

Итак, наличие 100500 классов еще никак не делает проект ооп-шным. Настоящее ООП начинается с выходом на арену S.O.L.I.D., Domain-Driven Development, DI-фреймворков и прочих мастодонтов (но не мастдаев).

*В иной плоскости лежит сам вопрос состоятельности объектно-ориентированной парадигмы как таковой. Здесь он даже не обсуждается, т.к. курс посвящен именно ООП. Но глупо было бы отрицать, что есть ряд задач, которые лучше решать в функциональной парадигме или даже процедурной, а не городить иерархии классов и интерфейсов. Но если мы взялись за ООП, то надо взяться за него правильно (не браться за private parts... да что ж такое сегодня происходит, опять игра слов)*

## Утончение модели и представления

Прежде чем разбираться со спагетти-кодом, примем весьма стандартное архитектурное решение - переведем проект на MV* рельсы.

В мире высокой моды, как известно, модели сидят на диете. Так и в разработке ПО - модель садят "на диету" (а заодно и представление). (Надеюсь, до меня никто не использовал эту игру слов; в противном случае - приношу тому человеку извинения).

До этого у нас все было моделью: карты, игроки, игра. Эти объекты занимались всем подряд - и хранили свое состояние, и взаимодействовали друг с другом (кто как), и вводили информацию от пользователя, и выводили себя на экран. Интуитивно понятно, что расширяемости и тестируемости сия организация кода никак не прибавляет. 

Отделить слои представления и контроллера от модели догадались-то очень давно, поэтому особо акцентировать внимание на этом не будем. Отметим разве только, что, хоть соответствующий класс в новой версии мы назвали ```BlackjackController```, с т.з. паттернов он является не контроллером, а презентером (реализован паттерн MVP). Презентер отличается от контроллера тем, что он берет на себя все взаимодействия модели с представлением (так что эти оба друг о друге ничего не должны знать).

Вся логика работы с консолью находится теперь в одном классе - ```ConsoleView```, который реализует общий интерфейс представлений игр ```IGameView```.

PS. Ну почти - одна функция представления (```outputCardTable()```) все же отходит от MVP и ждет в качестве параметра ссылку на игру
(впрочем, этот параметр можно спокойно при желании заменить на набор "сырых" данных).

## К состояниям и стратегиям

Как лечатся хвори с запутанными ветвлениями и невозможностью тестирования? Ответ: подорожником в виде поведенческих паттернов. Их даже не обязательно применять в чистом виде. Одно только изучение данных паттернов уже позволяет понять, как программист может закодить с помощью классов (которые, казалось бы, выражают чисто "статику" предметной области в виде иерархии сущностей) поведение системы (которое, казалось бы, программируется только в процедурных кусках кода).

Одними из самых простых и популярных поведенческих паттернов GOF являются паттерны **Стратегия** и **Состояние**, которые весьма хорошо подходят, в частности, для игр. Их UML-диаграммы практически ничем не отличаются, и их смысл заключается в том, чтобы инкапсулировать состояния и алгоритмы функционирования игры (стратегии) и уже в рамках этих состояний и стратегий реализовать все ветвления.

С т.з. паттерна **Состояние** контроллер явлется контекстом, а классы состояний мы напишем отдельно - по одному на каждое состояние. В контроллере закодирована универсальная схема игры - начинаем с состояния ```InitialDealState``` (состояние начальной раздачи карт) и заканчиваем ```GameOverState``` (состояние конца игры и подведения итогов). Переходы к следующим состояниям определяются внутри самих же состояний. Так, в методе ```update()``` состояния ```InitialDealState``` в зависимости от ситуации на игровом поле может инициироваться переход либо к состоянию ```PlayerActionState``` (при котором игрок получает карты), либо к состоянию ```EarlyBlackjackState``` (ранний блекджек, тогда игроку карты не даются, а предлагается взять выигрыш сразу, но 1-к-1). Игра находится всегда в каком-то одном состоянии, указатель на которое хранит переменная ```state_```.

Можем повторно использовать имеющиеся состояния путем композиции или наследования и можем добавлять новые - это нормально, т.к. новые сущности легко вписываются в существующую систему. При этом if-ы остаются, но они теперь малой вложенности и отвечают за что-то одно по смыслу.

## Зачем столько интерфейсов?

Расширяемость: мы можем подменять все, что касается алгоритмической части, инъектируя соответствующие зависимости. Таким образом из "кубиков" можно собрать любую карточную игру с любыми правилами. В предущей версии игры интерфейсов почти не было. Подумаем, как можно было тогда сэмулировать конкретные ситуации, например: "при начальной раздаче дилеру дать туза, а игроку - короля и туза; после этого игрок как будто выберет вариант "продолжить игру", дилер получит семерку, и игрок в конце концов выиграет". В старом коде все эти действия прошиты - карты достаются из колод в случайном порядке, действия игрока вводятся с консоли. Очевидно, такой код невозможно протестировать без явного изменения тестируемых участков кода.

Вот повествование дошло и до паттерна **Стратегия**. Введем интерфейсы, которые будут определять 1) стратегию раздачи карт, 2) правила игры и уже рассмотренное выше 3) взаимодействие с пользователем (интерфейс представления). Для нашего случая европейского блекджека реализуем эти интерфейсы в конкретных классах, наполнив их конкретными действиями. Контроллер агрегирует все эти интерфейсы и при создании конкретного контроллера в него будут инъектированы соответствующие объекты. Захотим - укажем контроллеру объект с обычной стратегией раздачи карт, а захотим - отнаследуемся от ```IDealStrategy``` фейковым классом EarlyBlackjackStrategy, который будет строго поставлять игроку и дилеру всегда такие карты, чтобы игра переходила в состояние раннего блекджека. Захотим - укажем контроллеру объект с обычными правилами, а захотим - отнаследуемся от RuleService фейковым классом ```Rules25```, где blackjack=25 и подадим контроллеру объект этого фейкового класса. Это изменение в одном лишь месте кода полностью поменяет всю игру.

## Зачем геттеры?

Зачем геттеры, если мы все равно открываем простой доступ к закрытым данным класса? Довольно распространенный и правильный вопрос, на который часто отвечают сухо: в соответствии с принципом инкапсуляции, нужно закрывать члены-данные класса. От себя возражаю на это: ну и что? Это инкапсуляция в узком смысле, и если бы только она была причиной, то делали бы соответствующие члены класса публичными - всяко доступ быстрее будет тогда. Инкапсуляция в широком смысле предполагает "найти то, что изменяется, и выделить это как-то особо". Так вот, геттер хорош тем, что это не просто метод, который достает закрытые данные, но это еще способ **указать контракт** получения интересующих клиента данных. Тогда можно в ключевых участках кода дергать полиморфные геттеры, чтобы уже на этапе выполнения программа определяла, как и откуда именно она возьмет данные. Например, в фейковых правилах переопределяется ```blackjackScore()``` так, что он возвращает всегда число 25, а внутри метода ```checkBlackjack()``` блекджек-счет не берется из внутреннего состояния объекта или из константы, а вызывается этот геттер (т.е. в коде не идет сравнение ```if (score == 21)``` или ```if (score == blackjack_)```, а именно так ```if (score == blackjackScore()```). Да, будет лишний вызов функции, но без геттера не получился бы здесь полиморфизм и гибкость.

## UML-картинки

Еще раз посмотрим на основную ОО-раскладку проекта:

![uml](https://github.com/ar1st0crat/CppCourse/blob/master/DemoProject/doc/uml.png)

После применения всего вышеперечисленного архитектура становится более прозрачной и тестируемой (как бы штамповано это не звучало).
Это не значит, что данный вариант образцовый. No-no-no, здесь есть всякое, что может кого-то не устроить. Например, контроллер толстоват. А кому-то, возможно, не понравится применение паттерна "Состояние" в этом проекте. Вариантов есть всегда у нас в запасе - главное, чтобы они были расширяемыми и тестируемыми.

Да, и язык С++, конечно, весьма многословен (verbose) для демонстрации развитого ООП. Поэтому когда какие-то участки кода этого проекта будут наводить тоску, перепроверьте себя - что именно не нравится - само ООП-решение или внешний вид конструкций и конвенции языка. Да, на шарпе все бы выглядело попроще и поприятнее, но по легкому пути пойти всегда еще успеется...


[Перейти к тестам](https://github.com/ar1st0crat/CppCourse/tree/master/DemoProject/test)


![screenshot](https://github.com/ar1st0crat/CppCourse/blob/master/DemoProject/doc/screenshot.png)
