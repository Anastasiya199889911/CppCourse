// TODO: убрать это подальше...

// Зачем столько интерфейсов?
// Расширяемость: мы можем подменять все, что касается алгоритмической части, инъектируя соответствующие зависимости.
// Таким образом из кубиков можно собрать любую карточную игру с любыми правилами.
// В контроллере закодирована универсальная схема игры - начинаем с состояния InitialDealState
// и заканчиваем GameOverState. Переходы к состояниям определяются внутри них же.

// Стратегия и состояния.
// Можем повторно использовать имеющие состояния путем композиции или наследования
// и можем добавлять новые - это нормально, т.к. новые сущности легко вписываются в существующую систему.
// При этом if-ы остаются, но они теперь малой вложенности и отвечают за что-то одно по смыслу.

// Зачем геттеры?
// Довольно частый и правильный вопрос, ответ на который меня лично часто не удовлетворяет.
// Ну и что?
// Геттер хорошо тем, что это не просто метод, который достает закрытые данные (в этом случае делали бы все пабликом),
// геттер - это способ **указать контракт** получения интересующей клиента сущности.

// Хоть и контроллер, но это MVP.
// Вся логика работы с консолью находится в одном классе - ConsoleView.
// PS. Ну почти - одна функция представления (outputCardTable) все же отходит от MVP и ждет в качестве параметра ссылку на игру
// (впрочем, этот параметр можно спокойно заменить на набор "сырых" данных)
//
// Итак, первое, что заметно - это много if-ов.
// В самих по себе ветвлениях плохого ничего нет (да, они увеличивают цикломатическую сложность,
// но надо же как-то реализовать путанную и изначально ветвистую бизнес-логику).
// Плохо становится тогда, когда они нагромождаются друг на друга и образуют спагетти-код, который невозможно тестить.
// Кроме того, эти ифы часто относятся к разным вещам: например, в условии внешней ветки проверяется, что дилер не набрал еще 17 очков,
// а во внутренней проверяется нужны ли бонусы игроку.

// Что можно сделать - выделить состояния и в рамках состояний инкапуслировать ветвления.
// Архитектура становится более прозрачной и тестируемой (как бы штамповано это не звучало))).


===

// Цель моков - прежде всего, проверить интеграцию компонентов системы:
// - что определенные методы вызываются определенное количество раз
// - что определенные методы вызываются в определенной последовательности
// - что определенные методы вызываются c определенными аргументами и возвращают определенный результат
// - и т.д.


// В интеграционных тестах (моки и стабы) можно делать акцент на разном:
// 1) мокать состояния, после чего переопределить в контроллере метод runGame(), где явно задать порядок смены состояний
//    (при этом акцент делается на тестировании самих состояний, а не контроллера в целом. Если реализация контроллера поменяется концептуально
//    (например, откажемся вообще от паттерна Состояние), то тесты окажутся бесполезны. В нашем примере мы такие тесты не делаем)
//
// 2) мокать все объекты, используемые контроллером (стратегию выдачи карт, правила игры и представление),
//    чтобы проверить общую логику работы игры. Поэтому контроллер изначально написан по TDD, т.е. так, чтобы
//    он содержал все методы, с помощью которых можно инъектировать необходимые данные с т.з. логики:
//      - методы-стратегии IDealStrategy выдачи карт игроку и дилеру giveCardToPlayer(), giveCardToDealer(). initialDeal()
//      - метод IGameView для получения ответа от игрока inputPlayerChoice()

// Итак, в наших тестах мы тестим как контроллер (в роли стаба), так и вью и дил (в роли моков).
// На контроллере мы проверяем, в каком состоянии он окажется и как изменятся деньги клиента.
// На моках мы проверяем как, когда и с какими параметрами вызываются методы.


/**
 * MockView - мок представления.
 *
 * В каждом отдельном тесте будем наворачивать на определенные методы определенную логику
 * средствами google mock и тестировать именно контроллер (т.е. интеграцию контроллера с представлением)
 *
 * Самым правильным вариантом является делать мок на основе интерфейса
 * (т.е. заглушки создаются для чисто виртуальных функций, ни на какие реализации упор не делается).
 */


/*
class TestSetupFail : public ::testing::Test
{
public:
    void SetUp()
    {
        view = std::make_unique<NiceMock<MockView>>();

        ON_CALL(*view, inputPlayerMoney())
                .WillByDefault(Return(20));

        fail_setup_controller = new GameController(std::move(view));
    }

    void TearDown()
    {
        delete fail_setup_controller;
    }

protected:
    std::unique_ptr<NiceMock<MockView>> view;
    GameController* fail_setup_controller;
};
*/


//https://github.com/google/googlemock/blob/master/googlemock/docs/CheatSheet.md#matchers

/*
Матчеры общего назначения:
Eq(value) or value	argument == value
Ge(value)	argument >= value
Gt(value)	argument > value
Le(value)	argument <= value
Lt(value)	argument < value
Ne(value)	argument != value
IsNull()	argument is a NULL pointer (raw or smart).
NotNull()	argument is a non-null pointer (raw or smart).
Ref(variable)	argument is a reference to variable.
TypedEq<type>(value)	argument has type type and is equal to value. You may need to use this instead of Eq(value) when the mock function is overloaded.

Строковые матчеры:
The argument can be either a C string or a C++ string object:
ContainsRegex(string)	argument matches the given regular expression.
EndsWith(suffix)	argument ends with string suffix.
HasSubstr(string)	argument contains string as a sub-string.
MatchesRegex(string)	argument matches the given regular expression with the match starting at the first character and ending at the last character.
StartsWith(prefix)	argument starts with string prefix.
StrCaseEq(string)	argument is equal to string, ignoring case.
StrCaseNe(string)	argument is not equal to string, ignoring case.
StrEq(string)	argument is equal to string.
StrNe(string)	argument is not equal to string.
*/
