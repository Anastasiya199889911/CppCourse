# Лекция 7 - Агрегация/композиция, наследование, друзья

План:

* Связи типа *has-a*, агрегация, композиция
* Дружественные классы, методы, функции
* Дружественность и перегрузка операторов
* Копаясь в ```<iostream>```...
* Агрегация/композиция vs. Наследование


Итак, у нас уже седьмая лекция, и только сейчас мы закодим хоть какую-то динамику в нашем проекте )). Нельзя сказать, что это напрямую связано с агрегацией/композицией; просто пришло время... Для пущей философскости последней фразы завершу ее словами "подумай над этим..."

### Класс-фасад TaxiService

Итак, к этому моменту у нас уже есть пример агрегации: водитель **Driver** агрегирует машину **Vehicle**. Соберем весь ворох классов, нажитых в предыдущих лекциях непосильным трудом, под одной крышей - классом **TaxiService**. Но это не просто технический шаг, ведь когда мы думаем о службе такси, то и представляем, что там есть какие-то операторы и водители с машинами, фиксируются и обрабатываются заказы и т.д.; значит, так и надо проектировать (возможно, потом потребуется рефакторинг, но первоначальный дизайн чаще всего делается на основе таких простых интуитивных представлений). Этот класс будет скрывать в своих недрах, как именно он там работает со всеми своими объектами, а клиентскому коду будет предоставлять некоторый набор удобных функций для управления своим состоянием, которое в том числе складывается из состояний объектов (собственно, инкапсуляция, как она и есть). Такие классы называются *фасадами*. Класс **TaxiService** реализует более строгую форму агрегации и является *композитом* для всех операторов, водителей и машин службы такси, т.е. в классе хранятся массивы этих объектов, которые будут созданы при создании службы такси и удалены, когда ее удалим. Массивы - это временно, скоро на арену выйдет STL.

Итак, где же та самая динамика? Здеся:

```C++
// основная функция - обработка звонка клиента

void TaxiService::processCall(std::tm call_time)
{
    // сначала поручаем оператору сформировать заказ:

    Booking* booking = operator->processBooking(call_time);

    // затем поручаем нашему сервису подобрать водителя под этот заказ

    Driver* driver = findDriver(*booking);

    // покажем клиенту информацию по заказу:

    std::cout << "Your car: ";
    driver->getVehicle()->print();

    // здесь поручим гео-службе оценить расстояние и время заказа
    // и выведем клиенту тоже

    std::cout << "Estimated distance and time: "
              << geo_service->calculateDistance(
                     (*booking)[0],
                     (*booking)[1]) << " km; "
              << geo_service->estimateTime(
                     (*booking)[0],
                     (*booking)[1]) << " seconds"
              << std::endl;


    // проэмулируем отработку заказа водителем:

    driver->handleBooking(*booking);

    // добавим заказ в журнал заказов:

    bookings_[bookings_count_++] = booking;
}
```

Код не требует детального разжевывания. Отметим, сколько классов вовлечено в действо: тут тебе и заказ Booking, и Operator, который формирует первоначальную версию этого самого заказа (на основе вопросов "Откуда ехать будете?", "Куда Вам?" и "Легковой или грузовой?"), и сама служба такси, которая подыскивает автоматически водителя (findDriver), и водитель Driver, который заказ выполняет, и даже дергаются методы гео-службы GeoService. А с точки зрения клиента всего лишь вызывается метод processCall() с датой-временем звонка клиента.

В соответствии с темой лекции, для демонстрации дружественности также изменен класс Booking - теперь перегруженные операторы стали friend + написан оператор<< для работы с потоками вывода. А еще реализована самая правильная версия метода ```swap()``` для реализации идиомы copy-and-swap (еще более правильная, чем была в прошлой версии).

В функции ```main()``` проэмулирована обработка двух звонков, после чего данные записываются в файл ```taxi.txt``` (такая простенькая текстовая сериализация, для этого добавили в проект еще интерфейс **ISerializable**).

Обработка одного звонка в консоли выглядит примерно следующим образом:

![screenshot](https://github.com/ar1st0crat/CppCourse/blob/master/Lectures/Lec07%20-%20Composition%20over%20Inheritance%20and%20Friends/screen.png)


Файл ```taxi.txt``` будет выглядеть как-то так:

```

Booking 8:15:20 -> 8:25:20
Digital Planetarium -> Donbass Arena

Booking 9:44:32 -> 9:54:32
Teatralniy, 13 -> Universitetskaya, 24

```

Последний заказ был сложным - аж 10 минут на грузовике ехали )).

Ну и посмотрим на UML-картинку на данный момент (интерфейс IPrintable не нарисован, чтобы не зашумлять диаграмму):

![uml](https://github.com/ar1st0crat/CppCourse/blob/master/Lectures/Lec07%20-%20Composition%20over%20Inheritance%20and%20Friends/uml.png)
