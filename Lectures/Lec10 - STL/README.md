# Лекция 10 - Библиотека STL

План:

* Контейнеры, адаптеры
* Итераторы
* Алгоритмы
* Функторы
* Рецепты STL


### STLdemo

Подпроект, в котором демонстрируется применение и особенности последовательностных и ассоциативных контейнеров, алгоритмов и функторов, предоставляемых библиотекой STL. Помимо совсем базовых затронуты такие вопросы, как:

- Адаптеры контейнеров ```std::stack```, ```std::queue```, ```std::priority_queue```
- Подробно об итераторах, трюки с итераторами и ```std::back_inserter```
- Словарь на основе хеш-таблицы ```std::unordered_map``` с примером реализации своего типа в качестве ключа
- Особая специализация вектора ```std::vector<bool>``` и тип ```std::bitset```
- Идиома erase-remove
- Немножко синтаксиса C++11

В STL есть огромное число готовых (и весьма оптимизированных) функций; целесообразно применять их.
Например, числа от 1 до 10 можно вывести с помощью STL, не написав ни строчки цикла или ветвления:

```C++

    std::vector<int> numbazz(10);
    std::iota(numbazz.begin(), numbazz.end(), 1);
    std::for_each(numbazz.begin(), numbazz.end(), print);

```


### TaxiService

Функционал системы не изменялся. Массивы в классах ```Booking``` и ```TaxiService``` заменены на ```std::vector```. Соответственно, вся работа с коллекциями ведется теперь через методы ```std::vector``` и алгоритмы из ```<algorithm>``` (остались также и old-school-циклы, но переведены на синтаксис с++11; в методе ```findDriver``` закралась лямбда, хотя это тема уже лекции №12). Что ж, код стал короче. Рассмотрен вопрос ```vec.at(i) vs. vec[i]``` с точки зрения исключений (см. код перегруженного оператора+= в классе ```Booking```).
