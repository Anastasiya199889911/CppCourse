#include <iostream>
#include "driver.h"

// =======================================================================================
// Сразу обсудим такой момент: у водителя есть машина (спасибо, кэп).
// С точки зрения кода это означает, что объект Driver держит указатель на объект Car.

// Вопрос: что делать при удалении водителя? удалять машину или нет?
// Иными словами, насколько сильно привязана машина к водителю с т.з. всей системы?
// Кто владеет машиной - водитель или система?
// Это вопрос композиции vs. агрегации, о нем - в соответствующей лекции будет речь.

// В нашем примере реализована агрегация, т.е. машиной владеет система,
// а водители только хранят указатель на свою машину.

// В этой лекции нам это важно только для демонстрации глубокого копирования:
// когда водитель будет копироваться, что должно происходить с его машиной?..
// =======================================================================================

Driver::Driver() :
    name_("unknown"), rate_(0.0), car_(nullptr)     // nullptr - это только для c++11 и выше
{                                                   // в старом С++ можно заменить на NULL или просто на 0
}

Driver::Driver(const std::string& name)
    : name_(name), rate_(0.0), car_(nullptr)
{
}

Driver::Driver(const std::string& name, const Car& car)
    : name_(name), rate_(0.0), car_(&car)
{
}

// По умолчанию копирующий конструктор создается компилятором автоматически,
// но он выполняет shallow copy, т.е. просто копирует все стековые данные класса.
// При узком копировании новый водитель скопировал бы себе ссылку на ту же машину, что и копируемый).

// В коде ниже мы для примера нарушаем это поведение:

Driver::Driver(const Driver& driver)
{
    name_ = driver.name_;
    car_ = nullptr;             // копия водителя будет без машины вообще
                                // только для примера! 
                                // в реальности делать это бессмысленно
                                // (надо либо делать настоящее deep-копирование, 
                                //  либо оставлять shallow-копирование по умолчанию)
}

// Ниже пример настоящего deep copy
// (его бы мы использовали, если бы водители владели экземплярами машин, а не только ссылками)

/*
Driver::Driver(const Driver& driver)
{
    name_ = driver.name_;

    // создаем новую машину с теми же характеристиками, что и машина копируемого водителя
    //(хотя лучше было бы написать и вызвать конструктор копирования класса Car)

    car_ = new Car(
                    driver.car_->getMake(),
                    driver.car_->getModel(),
                    driver.car_->getNo(),
                    driver.car_->getColor(),
                    driver.car_->getYear(),
                  );
}
 */


// в деструкторе подчищаем память, если хотим реализовать
// логику "машины без водителя быть не может".

Driver::~Driver()
{
    //delete car_;
}
// если мы оперируем машинами безотносительно к водителям,
// то подчищать память здесь не нужно (в нашем проекте именно так)

// Это вопрос композиции vs. агрегации, о нем - в соотв. лекции



void Driver::setCar(const Car& car)
{
    car_ = &car;
}

void Driver::setRate(double rate)
{
    this->rate_ = rate;

    if (rate > top_rate)
    {
        top_rate = rate;
    }
}

// Остановимся на этом методе, чтобы рассмотреть одну штуку.
// Например:
//
// Driver d1("Ivanov");
// Driver d2("Petrov");
//
// d1.setRate(8.0);
// d2.setRate(9.2);
//
// Откуда компилятор знает, с какими данными вызывать функцию setRate()?
// Код метода хранится в оперативной памяти и он один для всех объектов (и d1, и d2).
// Значит, нужно как-то передать в метод указатель на сам объект.
// Это компилятор и делает, он преобразует метод setRate() в такой метод:

//          void Driver::setRate(Driver* this, double rate)

// Первым параметром неявно всегда идет указатель на объект this.
// (Еслм метод константный, то и указатель будет const Driver* this)


void Driver::setName(const std::string& name)
{
    name_ = name;
}

const Car* Driver::getCar() const
{
    return car_;
}

std::string Driver::getName() const
{
    return name_;
}

double Driver::getRate() const
{
    return rate_;
}

void Driver::print() const
{
    if (car_)
    {
        std::cout << name_ << " drives " << car_->getModel() << " " << car_->getNo() << std::endl << std::endl;
    }
    else
    {
        std::cout << name_ << " is currently without a car" << std::endl << std::endl;
    }
}

// статический член класса
double Driver::top_rate = 0.0;
